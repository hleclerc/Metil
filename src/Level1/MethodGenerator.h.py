# -*- coding: utf-8 -*-
from MethodHelper import *

def make_gene( methods ):
    # MethodGenerator
    for m in methods:
        if m != 'SO':
            n = m[1:].count( "O" ) + m[1:].count( "o" )
            print 'template<class N>'
            print 'struct MethodGenerator<Type::Method_' + m + ',N> {'
            print '    static ' + cor( m[ 0 ] ) + 'generator( ' + args( m ) + ' ) {'
            for c, i in zip( m[1:], range( 1000) ):
                if c in "oO":
                    print '        ' + string.ascii_lowercase[ i ] + '.type->init_if_necessary();'
            acc = 'N::access( a.type )' + '[ b.type->number ]' * ( n == 2 )
            arg = string.join( [ string.ascii_lowercase[ i ] + '.type' for i in range( n ) ], ', ' )
            print '        ' + acc + ' = MethodFinder<N>::find( ' + arg + ' );'
            print '        return ' + acc + '( ' + arg_names( m ) + ' );'
            print '    }'
            print '};'
            print ''


   
print '// file generated by MethodGenerator.h.py'
print '#ifndef METHODGENERATOR_H'
print '#define METHODGENERATOR_H'
print ''
print '#include "MethodFinder.h"'
print ''
print 'BEG_METIL_LEVEL1_NAMESPACE;'
print ''
print 'template<class T,class N>'
print 'struct MethodGenerator {};'
print ''
make_gene( methods )
print ''
print 'END_METIL_LEVEL1_NAMESPACE;'
print ''
print '#endif // METHODGENERATOR_H'

