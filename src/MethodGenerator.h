// file generated by MethodGenerator.h.py
#ifndef METHODGENERATOR_H
#define METHODGENERATOR_H

#include "MethodFinder.h"

BEG_METIL_LEVEL1_NAMESPACE;

template<class T,class N>
struct MethodGenerator {};

template<class N>
struct MethodGenerator<Type::Method_Vo,N> {
    static void generator( MO &a ) {
        a.type->init_if_necessary();
        N::access( a.type ) = MethodFinder<N>::find( a.type );
        return N::access( a.type )( a );
    }
};

template<class N>
struct MethodGenerator<Type::Method_OO,N> {
    static MO generator( MO a ) {
        a.type->init_if_necessary();
        N::access( a.type ) = MethodFinder<N>::find( a.type );
        return N::access( a.type )( a );
    }
};

template<class N>
struct MethodGenerator<Type::Method_BO,N> {
    static bool generator( MO a ) {
        a.type->init_if_necessary();
        N::access( a.type ) = MethodFinder<N>::find( a.type );
        return N::access( a.type )( a );
    }
};

template<class N>
struct MethodGenerator<Type::Method_IO,N> {
    static SI32 generator( MO a ) {
        a.type->init_if_necessary();
        N::access( a.type ) = MethodFinder<N>::find( a.type );
        return N::access( a.type )( a );
    }
};

template<class N>
struct MethodGenerator<Type::Method_LO,N> {
    static SI64 generator( MO a ) {
        a.type->init_if_necessary();
        N::access( a.type ) = MethodFinder<N>::find( a.type );
        return N::access( a.type )( a );
    }
};

template<class N>
struct MethodGenerator<Type::Method_FO,N> {
    static FP32 generator( MO a ) {
        a.type->init_if_necessary();
        N::access( a.type ) = MethodFinder<N>::find( a.type );
        return N::access( a.type )( a );
    }
};

template<class N>
struct MethodGenerator<Type::Method_DO,N> {
    static FP64 generator( MO a ) {
        a.type->init_if_necessary();
        N::access( a.type ) = MethodFinder<N>::find( a.type );
        return N::access( a.type )( a );
    }
};

template<class N>
struct MethodGenerator<Type::Method_EO,N> {
    static FP80 generator( MO a ) {
        a.type->init_if_necessary();
        N::access( a.type ) = MethodFinder<N>::find( a.type );
        return N::access( a.type )( a );
    }
};

template<class N>
struct MethodGenerator<Type::Method_VOt,N> {
    static void generator( MO a, String &b ) {
        a.type->init_if_necessary();
        N::access( a.type ) = MethodFinder<N>::find( a.type );
        return N::access( a.type )( a, b );
    }
};

template<class N>
struct MethodGenerator<Type::Method_pO,N> {
    static void *generator( MO a ) {
        a.type->init_if_necessary();
        N::access( a.type ) = MethodFinder<N>::find( a.type );
        return N::access( a.type )( a );
    }
};

template<class N>
struct MethodGenerator<Type::Method_Vot,N> {
    static void generator( MO &a, String &b ) {
        a.type->init_if_necessary();
        N::access( a.type ) = MethodFinder<N>::find( a.type );
        return N::access( a.type )( a, b );
    }
};

template<class N>
struct MethodGenerator<Type::Method_po,N> {
    static void *generator( MO &a ) {
        a.type->init_if_necessary();
        N::access( a.type ) = MethodFinder<N>::find( a.type );
        return N::access( a.type )( a );
    }
};

template<class N>
struct MethodGenerator<Type::Method_VoPS,N> {
    static void generator( MO &a, const void *b, ST c ) {
        a.type->init_if_necessary();
        N::access( a.type ) = MethodFinder<N>::find( a.type );
        return N::access( a.type )( a, b, c );
    }
};

template<class N>
struct MethodGenerator<Type::Method_VOpS,N> {
    static void generator( MO a, void *b, ST c ) {
        a.type->init_if_necessary();
        N::access( a.type ) = MethodFinder<N>::find( a.type );
        return N::access( a.type )( a, b, c );
    }
};

template<class N>
struct MethodGenerator<Type::Method_OOO,N> {
    static MO generator( MO a, MO b ) {
        a.type->init_if_necessary();
        b.type->init_if_necessary();
        N::access( a.type )[ b.type->number ] = MethodFinder<N>::find( a.type, b.type );
        return N::access( a.type )[ b.type->number ]( a, b );
    }
};

template<class N>
struct MethodGenerator<Type::Method_BOO,N> {
    static bool generator( MO a, MO b ) {
        a.type->init_if_necessary();
        b.type->init_if_necessary();
        N::access( a.type )[ b.type->number ] = MethodFinder<N>::find( a.type, b.type );
        return N::access( a.type )[ b.type->number ]( a, b );
    }
};

template<class N>
struct MethodGenerator<Type::Method_VoO,N> {
    static void generator( MO &a, MO b ) {
        a.type->init_if_necessary();
        b.type->init_if_necessary();
        N::access( a.type )[ b.type->number ] = MethodFinder<N>::find( a.type, b.type );
        return N::access( a.type )[ b.type->number ]( a, b );
    }
};

template<class N>
struct MethodGenerator<Type::Method_OoO,N> {
    static MO generator( MO &a, MO b ) {
        a.type->init_if_necessary();
        b.type->init_if_necessary();
        N::access( a.type )[ b.type->number ] = MethodFinder<N>::find( a.type, b.type );
        return N::access( a.type )[ b.type->number ]( a, b );
    }
};

#define NB_ARGS_METHOD_Vo 1
#define NB_ARGS_METHOD_OO 1
#define NB_ARGS_METHOD_BO 1
#define NB_ARGS_METHOD_IO 1
#define NB_ARGS_METHOD_LO 1
#define NB_ARGS_METHOD_SO 1
#define NB_ARGS_METHOD_FO 1
#define NB_ARGS_METHOD_DO 1
#define NB_ARGS_METHOD_EO 1
#define NB_ARGS_METHOD_VOt 1
#define NB_ARGS_METHOD_pO 1
#define NB_ARGS_METHOD_Vot 1
#define NB_ARGS_METHOD_po 1
#define NB_ARGS_METHOD_VoPS 1
#define NB_ARGS_METHOD_VOpS 1
#define NB_ARGS_METHOD_OOO 2
#define NB_ARGS_METHOD_BOO 2
#define NB_ARGS_METHOD_VoO 2
#define NB_ARGS_METHOD_OoO 2

END_METIL_LEVEL1_NAMESPACE;

#endif // METHODGENERATOR_H
